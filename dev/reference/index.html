<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer reference · Rebugger.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Rebugger.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li><a class="toctext" href="../config/">Configuration</a></li><li><a class="toctext" href="../limitations/">Limitations</a></li><li><a class="toctext" href="../internals/">How Rebugger works</a></li><li class="current"><a class="toctext" href>Developer reference</a><ul class="internal"><li><a class="toctext" href="#Capturing-arguments-1">Capturing arguments</a></li><li><a class="toctext" href="#Capturing-stacktrace-1">Capturing stacktrace</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Developer reference</a></li></ul><a class="edit-page" href="https://github.com/timholy/Rebugger.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Developer reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Developer-reference-1" href="#Developer-reference-1">Developer reference</a></h1><h2><a class="nav-anchor" id="Capturing-arguments-1" href="#Capturing-arguments-1">Capturing arguments</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.stepin" href="#Rebugger.stepin"><code>Rebugger.stepin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stepin(s)</code></pre><p>Given a buffer <code>s</code> representing a string and &quot;point&quot; (the seek position) set at a call expression, replace the contents of the buffer with a <code>let</code> expression that wraps the <em>body</em> of the callee.</p><p>For example, if <code>s</code> has contents</p><pre><code class="language-none">&lt;some code&gt;
if x &gt; 0.5
    ^fcomplex(x)
    &lt;more code&gt;</code></pre><p>where in the above <code>^</code> indicates <code>position(s)</code> (&quot;point&quot;), and if the definition of <code>fcomplex</code> is</p><pre><code class="language-none">function fcomplex(x::A, y=1, z=&quot;&quot;; kw1=3.2) where A&lt;:AbstractArray{T} where T
    &lt;body&gt;
end</code></pre><p>rewrite <code>s</code> so that its contents are</p><pre><code class="language-none">@eval ModuleOf_fcomplex let (x, y, z, kw1, A, T) = Main.Rebugger.getstored(id)
    &lt;body&gt;
end</code></pre><p>where <code>Rebugger.getstored</code> returns has been pre-loaded with the values that would have been set when you called <code>fcomplex(x)</code> in <code>s</code> above. This line can be edited and <code>eval</code>ed at the REPL to analyze or improve <code>fcomplex</code>, or can be used for further <code>stepin</code> calls.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/ui.jl#L75-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.prepare_caller_capture!" href="#Rebugger.prepare_caller_capture!"><code>Rebugger.prepare_caller_capture!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">callexpr = prepare_caller_capture!(io)</code></pre><p>Given a buffer <code>io</code> representing a string and &quot;point&quot; (the seek position) set at a call expression, replace the call with one that stashes the function and arguments of the call.</p><p>For example, if <code>io</code> has contents</p><pre><code class="language-none">&lt;some code&gt;
if x &gt; 0.5
    ^fcomplex(x, 2; kw1=1.1)
    &lt;more code&gt;</code></pre><p>where in the above <code>^</code> indicates <code>position(s)</code> (&quot;point&quot;), rewrite this as</p><pre><code class="language-none">&lt;some code&gt;
if x &gt; 0.5
    Main.Rebugger.stashed[] = (fcomplex, (x, 2), (kw1=1.1,))
    throw(Rebugger.StopException())
    &lt;more code&gt;</code></pre><p>(Keyword arguments do not affect dispatch and hence are not stashed.) Consequently, if this is <code>eval</code>ed and execution reaches &quot;^&quot;, it causes the arguments of the call to be placed in <code>Rebugger.stashed</code>.</p><p><code>callexpr</code> is the original (unmodified) expression specifying the call, i.e., <code>fcomplex(x, 2; kw1=1.1)</code> in this case.</p><p>This does the buffer-preparation for <em>caller</em> capture. For <em>callee</em> capture, see <a href="#Rebugger.method_capture_from_callee"><code>method_capture_from_callee</code></a>, and <a href="#Rebugger.stepin"><code>stepin</code></a> which puts these two together.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L299-L330">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.method_capture_from_callee" href="#Rebugger.method_capture_from_callee"><code>Rebugger.method_capture_from_callee</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uuid = method_capture_from_callee(method; overwrite::Bool=false)</code></pre><p>Create a version of <code>method</code> that stores its inputs in <code>Main.Rebugger.stored</code>. For a method</p><pre><code class="language-none">function fcomplex(x::A, y=1, z=&quot;&quot;; kw1=3.2) where A&lt;:AbstractArray{T} where T
    &lt;body&gt;
end</code></pre><p>if <code>overwrite=false</code>, this generates a new method</p><pre><code class="language-none">function hidden_fcomplex(x::A, y=1, z=&quot;&quot;; kw1=3.2) where A&lt;:AbstractArray{T} where T
    Main.Rebugger.stored[uuid] = Main.Rebugger.Stored(fcomplex, (:x, :y, :z, :kw1, :A, :T), deepcopy((x, y, z, kw1, A, T)))
    throw(StopException())
end</code></pre><p>(If a <code>uuid</code> already exists for <code>method</code> from a previous call to <code>method_capture_from_callee</code>, it will simply be returned.)</p><p>With <code>overwrite=true</code>, there are two differences:</p><ul><li>it replaces <code>fcomplex</code> rather than defining <code>hidden_fcomplex</code></li><li>rather than throwing <code>StopException</code>, it re-inserts <code>&lt;body&gt;</code> after the line performing storage</li></ul><p>The returned <code>uuid</code> can be used for accessing the stored data.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L397-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.signature_names!" href="#Rebugger.signature_names!"><code>Rebugger.signature_names!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fname, argnames, kwnames, parameternames = signature_names!(sigex::Expr)</code></pre><p>Return the function name <code>fname</code> and names given to its arguments, keyword arguments, and parameters, as specified by the method signature-expression <code>sigex</code>.</p><p><code>sigex</code> will be modified if some of the arguments are unnamed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Rebugger.signature_names!(:(complexargs(w::Ref{A}, @nospecialize(x::Integer), y, z::String=&quot;&quot;; kwarg::Bool=false, kw2::String=&quot;&quot;, kwargs...) where A &lt;: AbstractArray{T,N} where {T,N}))
(:complexargs, (:w, :x, :y, :z), (:kwarg, :kw2, :kwargs), (:A, :T, :N))

julia&gt; ex = :(myzero(::Float64));     # unnamed argument

julia&gt; Rebugger.signature_names!(ex)
(:myzero, (:__Float64_1,), (), ())

julia&gt; ex
:(myzero(__Float64_1::Float64))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L522-L545">source</a></section><h2><a class="nav-anchor" id="Capturing-stacktrace-1" href="#Capturing-stacktrace-1">Capturing stacktrace</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.capture_stacktrace" href="#Rebugger.capture_stacktrace"><code>Rebugger.capture_stacktrace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uuids = capture_stacktrace(mod, command)</code></pre><p>Execute <code>command</code> in module <code>mod</code>. <code>command</code> must throw an error. Then instrument the methods in the stacktrace so that their input variables are stored in <code>Rebugger.stored</code>. After storing the inputs, restore the original methods.</p><p>Since this requires two <code>eval</code>s of <code>command</code>, usage should be limited to deterministic expressions that always result in the same call chain.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L187-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.pregenerated_stacktrace" href="#Rebugger.pregenerated_stacktrace"><code>Rebugger.pregenerated_stacktrace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">usrtrace, defs = pregenerated_stacktrace(trace, topname=:capture_stacktrace)</code></pre><p>Generate a list of methods <code>usrtrace</code> and their corresponding definition-expressions <code>defs</code> from a stacktrace. Not all methods can be looked up, but this attempts to resolve, e.g., keyword-handling methods and so on.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L82-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.linerange" href="#Rebugger.linerange"><code>Rebugger.linerange</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">r = linerange(expr, offset=0)</code></pre><p>Compute the range of lines occupied by <code>expr</code>. Returns <code>nothing</code> if no line statements can be found.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L56-L61">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.clear" href="#Rebugger.clear"><code>Rebugger.clear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Rebugger.clear()</code></pre><p>Clear internal data. This deletes storage associated with stored variables, but also forces regeneration of capture methods, which can be handy while debugging Rebugger itself.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L40-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rebugger.getstored" href="#Rebugger.getstored"><code>Rebugger.getstored</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">args_and_types = Rebugger.getstored(uuid)</code></pre><p>Retrieve the values of stored arguments and type-parameters from the store specified <code>uuid</code>. This makes a copy of values, so as to be safe for repeated execution of methods that modify their inputs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timholy/Rebugger.jl/blob/a6217c7a1f526ddfe124294a9d38cbc5c27261c3/src/debug.jl#L504-L510">source</a></section><footer><hr/><a class="previous" href="../internals/"><span class="direction">Previous</span><span class="title">How Rebugger works</span></a></footer></article></body></html>
