<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How Rebugger works · Rebugger.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Rebugger.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li><a class="toctext" href="../config/">Configuration</a></li><li><a class="toctext" href="../limitations/">Limitations</a></li><li class="current"><a class="toctext" href>How Rebugger works</a><ul class="internal"><li><a class="toctext" href="#Implementation-of-&quot;step-in&quot;-1">Implementation of &quot;step in&quot;</a></li><li><a class="toctext" href="#Implementation-of-&quot;catch-stacktrace&quot;-1">Implementation of &quot;catch stacktrace&quot;</a></li></ul></li><li><a class="toctext" href="../reference/">Developer reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>How Rebugger works</a></li></ul><a class="edit-page" href="https://github.com/timholy/Rebugger.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>How Rebugger works</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="How-Rebugger-works-1" href="#How-Rebugger-works-1">How Rebugger works</a></h1><p>Rebugger traces execution through use of expression-rewriting and Julia&#39;s ordinary <code>try/catch</code> control-flow. It maintains internal storage that allows other methods to &quot;deposit&quot; their arguments (a <em>store</em>) or temporarily <em>stash</em> the function and arguments of a call.</p><h2><a class="nav-anchor" id="Implementation-of-&quot;step-in&quot;-1" href="#Implementation-of-&quot;step-in&quot;-1">Implementation of &quot;step in&quot;</a></h2><p>Rebugger makes use of the buffer containing user input: not just its contents, but also the position of &quot;point&quot; (the seek position) to indicate the specific call expression targeted for stepping in.</p><p>For example, if a buffer has contents</p><pre><code class="language-julia">    # &lt;some code&gt;
    if x &gt; 0.5
        ^fcomplex(x, 2; kw1=1.1)
        # &lt;more code&gt;</code></pre><p>where in the above <code>^</code> indicates &quot;point,&quot; Rebugger uses a multi-stage process to enter <code>fcomplex</code> with appropriate arguments:</p><ul><li>First, it carries out <em>caller capture</em> to determine which function is being called at point, and with which arguments. The main goal here is to be able to then use <code>which</code> to determine the specific method.</li><li>Once armed with the specific method, it then carries out <em>callee capture</em> to obtain all the inputs to the method. For simple methods this may be redundant with <em>caller capture</em>, but <em>callee capture</em> can also obtain the values of default arguments, keyword arguments, and type parameters.</li><li>Finally, Rebugger rewrites the REPL command-line buffer with a suitably-modified version of the body of the called method, so that the user can inspect, run, and manipulate it.</li></ul><h3><a class="nav-anchor" id="Caller-capture-1" href="#Caller-capture-1">Caller capture</a></h3><p>The original expression above is rewritten as</p><pre><code class="language-julia">    # &lt;some code&gt;
    if x &gt; 0.5
        Main.Rebugger.stashed[] = (fcomplex, (x, 2), (kw1=1.1,))
        throw(Rebugger.StopException())
        # &lt;more code&gt;</code></pre><p>Note that the full context of the original expression is preserved, thereby ensuring that we do not have to be concerned about not having the appropriate local scope for the arguments to the call of <code>fcomplex</code>. However, rather than actually calling <code>fcomplex</code>, this expression &quot;stashes&quot; the arguments and function in a temporary store internal to Rebugger. It then throws an exception type specifically crafted to signal that the expression executed and exited as expected.</p><p>This expression is then evaluated inside a block</p><pre><code class="language-julia">    try
        Core.eval(Main, caller_capture_expression)
        throw(StashingFailed())
    catch err
        err isa StashingFailed &amp;&amp; rethrow(err)
        if !(err isa StopException)
            throw(EvalException(content(buffer), err))
        end
    end</code></pre><p>Note that this looks for the <code>StopException</code>; this is considered the normal execution path. If the <code>StopException</code> is never hit, it means evaluation never reached the expression marked by &quot;point&quot; and thus leads to a <code>StashingFailed</code> exception. Any other error results in an <code>EvalException</code>, usually triggered by other errors in the block of code.</p><p>Assuming the <code>StopException</code> is hit, we then proceed to callee capture.</p><h3><a class="nav-anchor" id="Callee-capture-1" href="#Callee-capture-1">Callee capture</a></h3><p>Rebugger removes the function and arguments from <code>Rebugger.stashed[]</code> and then uses <code>which</code> to determine the specific method called. It then asks <a href="https://timholy.github.io/Revise.jl/stable/">Revise</a> for the expression that defines the method. It then analyzes the signature to determine the full complement of inputs and creates a new method that stores them. For example, if the applicable method of <code>fcomplex</code> is given by</p><pre><code class="language-julia">    function fcomplex(x::A, y=1, z=&quot;&quot;; kw1=3.2) where A&lt;:AbstractArray{T} where T
        # &lt;body&gt;
    end</code></pre><p>then Rebugger generates a new method</p><pre><code class="language-julia">    function hidden_fcomplex(x::A, y=1, z=&quot;&quot;; kw1=3.2) where A&lt;:AbstractArray{T} where T
        Main.Rebugger.stored[uuid] = Main.Rebugger.Stored(fcomplex, (:x, :y, :z, :kw1, :A, :T), deepcopy((x, y, z, kw1, A, T)))
        throw(StopException())
    end</code></pre><p>This method is then called from inside another <code>try/catch</code> block that again checks for a <code>StopException</code>. This results in the complete set of inputs being <em>stored</em>, a more &quot;permanent&quot; form of preservation than <em>stashing</em>, which only lasts for the gap between caller and callee capture. If one has the appropriate <code>uuid</code>, one can then extract these values at will from storage using <a href="../reference/#Rebugger.getstored"><code>Rebugger.getstored</code></a>.</p><h3><a class="nav-anchor" id="Generating-the-new-buffer-contents-(the-let-expression)-1" href="#Generating-the-new-buffer-contents-(the-let-expression)-1">Generating the new buffer contents (the <code>let</code> expression)</a></h3><p>Once callee capture is complete, the user can re-execute any components of the called method as desired. To make this easier, Rebugger replaces the contents of the buffer with a line that looks like this:</p><pre><code class="language-julia">@eval &lt;ModuleOf_fcomplex&gt; let (x, y, z, kw1, A, T) = Main.Rebugger.getstored(&quot;0123abc...&quot;)
    # &lt;body&gt;
end</code></pre><p>The <code>@eval</code> makes sure that the block will be executed within the module in which <code>fcomplex</code> is defined; as a consequence it will have access to all the unexported methods, etc., that <code>fcomplex</code> itself has. The <code>let</code> block ensures that these variables do not conflict with other objects that may be defined in <code>ModuleOf_fcomplex</code>. The values are unloaded from the store (making copies, in case <code>fcomplex</code> modifies its inputs) and then execution proceeds into <code>body</code>.</p><p>The user can then edit the buffer at will.</p><h2><a class="nav-anchor" id="Implementation-of-&quot;catch-stacktrace&quot;-1" href="#Implementation-of-&quot;catch-stacktrace&quot;-1">Implementation of &quot;catch stacktrace&quot;</a></h2><p>In contrast with &quot;step in,&quot; when catching a stacktrace Rebugger does not know the specific methods that will be used in advance of making the call. Consequently, Rebugger has to execute the call twice:</p><ul><li>the first call is used to obtain a stacktrace</li><li>The trace is analyzed to obtain the specific methods, which are then replaced with versions that place inputs in storage; see <a href="#Callee-capture-1">Callee capture</a>, with the differences<ul><li>the original method is (temporarily) overwritten by one that executes the store</li><li>this &quot;storing&quot; method also includes the full method body</li></ul>These two changes ensure that the &quot;call chain&quot; is not broken.</li><li>a second call (recreating the same error, for functions that have deterministic execution) is then made to store all the arguments at each captured stage of the stacktrace.</li><li>finally, the original methods are restored.</li></ul><footer><hr/><a class="previous" href="../limitations/"><span class="direction">Previous</span><span class="title">Limitations</span></a><a class="next" href="../reference/"><span class="direction">Next</span><span class="title">Developer reference</span></a></footer></article></body></html>
